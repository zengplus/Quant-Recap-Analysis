# AlphaGPT 实验文档 V0.1

> **版本**: V0.1 (Initial Release)
> **日期**: 2026-02-05
> **核心任务**: 搭建完整的机器学习 Alpha 挖掘流水线

本文档旨在梳理 AlphaGPT 项目 V0.1 版本的完整机器学习流程（Pipeline）。我们将按照**数据工程 -> 模型训练 -> 回测验证**的步骤，详细介绍各个环节的关键决策，重点对比不同技术路线的优劣，并解释为实盘仿真所做的特殊处理。

---

## 1. 机器学习全流程 (Pipeline Overview)

整个量化挖掘系统分为三个紧密耦合的阶段：

1.  **数据工程 (Data Engineering)**
    *   **核心动作**: 数据清洗、特征构建、归一化处理。
    *   **关键决策**: 采用**截面归一化 (Cross-Sectional Norm)** 而非时序归一化。
2.  **模型训练 (Model Training)**
    *   **核心动作**: 使用 Transformer 生成因子表达式，通过强化学习优化。
    *   **关键决策**: 引入 Looped Transformer 和 LoRD 正则化以适应低信噪比数据。
3.  **回测验证 (Backtesting)**
    *   **核心动作**: 历史数据回放、模拟交易撮合。
    *   **关键决策**: **双引擎验证** (JoinQuant vs Qlib) 与 **实盘仿真过滤** (涨跌停/停牌)。

---

## 2. 第一阶段：数据工程 (Data Engineering)

### 2.1 数据预处理与归一化对比

在处理量价特征（如过去 5 天的收益率）时，我们面临一个最根本的选择：是横向比（和别人比），还是纵向比（和自己比）？本项目坚定选择了**截面数据**。

#### 深度对比：截面数据 (Cross-Sectional) vs 时序数据 (Time-Series)

| 维度 | 截面数据 (Cross-Sectional) ✅ | 时序数据 (Time-Series) ❌ |
| :--- | :--- | :--- |
| **定义** | **横向对比**：每一天，将全市场 3000+ 只股票放在一起排名 (Ranking) 或标准化 (Z-Score)。 | **纵向对比**：对每一只股票，将其今天的数值与自己的历史数值（如过去 30 天均值）对比。 |
| **物理含义** | **选股 (Stock Selection)**：寻找相对强势股。“不管大盘涨跌，只要我比别人强，我就赢。” | **择时 (Market Timing)**：预测单只股票的涨跌趋势。“大盘跌了，我也得跌，所以我要空仓。” |
| **对 Beta 的处理** | **自动对冲 (Market Neutral)**：通过截面标准化，剔除了市场整体波动 (Beta)。Reward 纯粹来源于 Alpha (超额收益)。 | **包含 Beta**：模型容易学到“大盘不好就全都不买”，这在熊市虽然有效，但无法区分是个股好还是大盘好。 |
| **适用场景** | **Alpha 策略**、多因子选股、股票多空 (Long-Short)。 | **CTA 策略**、单边投机、趋势跟踪。 |
| **本项目决策** | **采用 (Rank 标准化)**：我们的目标是挖掘 Alpha 因子，必须强制模型学习“选优”能力，而非被动跟随市场波动。 | **仅用于特征平滑**：如计算“120日均线乖离率”作为特征输入，但 Reward 计算坚决不用。 |

### 2.2 防未来函数设计 (Anti-Lookahead)

*   **滚动窗口**: 特征计算严格基于 `t-N` 到 `t` 时刻的数据。
*   **物理切片**: 在 Dataloader 中，虽然加载了 730 天的历史数据用于计算滚动特征（如 120 天均线），但在进入训练循环前，通过 `slice_loader` 函数**物理切除**了这段 Buffer 数据，确保训练用的每一行数据都是“干净”的，且不占用显存。

---

## 3. 第二阶段：模型训练 (Model Training)

（本阶段简述，详见代码 `model_core/`）

*   **模型架构**: 使用 **Looped Transformer**，通过循环权重机制增加推理深度而不增加参数量，防止过拟合。
*   **优化算法**: 采用 **Reinforcement Learning (REINFORCE)**。
    *   **State**: 当前生成的公式片段。
    *   **Action**: 下一个数学符号或变量。
    *   **Reward**: 公式在校验集上的 **Sortino Ratio**（相比 Sharpe Ratio，更关注下行风险）。

---

## 4. 第三阶段：回测验证 (Backtesting)

为了确保策略“不仅在纸面上赚钱，在实盘中也能成交”，我们设计了严格的**双引擎验证**和**仿真过滤**机制。

### 4.1 双引擎对比 (Dual-Engine Check)

我们同时运行两套回测逻辑，以验证结果的鲁棒性。

| 特性 | 引擎 A: JoinQuant-Like (自研) | 引擎 B: Qlib (第三方库) |
| :--- | :--- | :--- |
| **核心机制** | **事件驱动 (Event-Driven)** | **向量化 (Vectorized)** |
| **运行方式** | 模拟真实的交易所，按天推进，逐日撮合订单。 | 基于矩阵运算，一次性算出所有日期的收益。 |
| **精度** | **高**：可以精确处理停牌、复牌、涨跌停无法成交等细节。 | **中**：通常假设以收盘价成交，忽略部分流动性细节。 |
| **速度** | 慢 (Python 循环) | 极快 (C++/Numpy 优化) |
| **定位** | **主裁判 (Final Verdict)**：实盘模拟的最终依据。 | **辅助验证 (Cross-Check)**：用于快速筛选因子。 |
| **决策逻辑** | 如果两者结果一致，通过；如果 Qlib 表现极好但 JoinQuant 表现差，说明策略可能利用了**流动性陷阱**（如买入了跌停股），必须剔除。 |

### 4.2 实盘仿真过滤 (Real-World Constraints)

在双引擎中，使用硬编码了以下规则，以模拟真实的 A 股交易环境：

1.  **剔除涨停股 (Limit-Up Filter)**
    *   **规则**: 如果某只股票当日最高价 == 涨停价 (High == Limit_Up)，则禁止买入。
    *   **原因**: A 股涨停板制度下，涨停股票通常无法买入。如果不剔除，回测会虚假成交，大幅虚高收益。

2.  **剔除跌停股 (Limit-Down Filter)**
    *   **规则**: 如果某只股票当日最低价 == 跌停价 (Low == Limit_Down)，则禁止卖出。
    *   **原因**: 跌停股票卖单堆积，实盘中很难卖出。如果不剔除，回测会显示“完美止损”，掩盖真实风险。

3.  **剔除停牌股 (Suspended Filter)**
    *   **规则**: 检查股票状态位，若为停牌状态，强行保持持仓不变，资金冻结。
    *   **原因**: 停牌期间资金无法挪用。

4.  **ST 与 次新股过滤**
    *   **规则**: 剔除 ST/PT 股票及上市不足 60 天的新股。
    *   **原因**: 规避退市风险和新股的非理性波动。

### 4.3 线上/线下对齐要点（公式修复与同分并列）

1.  **统一公式口径：先修复、再执行**
    *   训练输出的是 token 序列，但 token 可能不满足可执行表达式的语法约束。
    *   若直接执行 raw token，可能走缺参补默认值等兜底路径，导致“日志公式 ≠ 实际信号”。
    *   因此回测与复现实验统一以 `repair_postfix` 后的 token 作为最终执行依据，并在日志中记录 `tokens(raw)` / `tokens(repaired)` 以便对齐。

2.  **处理同分并列：TopK 入选会被股票池顺序主导**
    *   对于输出离散分数的公式（例如 `SIGN(RET)` 类），可能出现大量股票同分并列。
    *   当 TopK 截断点落在并列区间内，不同环境的股票池顺序差异会导致入选股票不同，进而放大收益差异。
    *   因此在调仓日志中加入“TopK 并列分数影响入选”的告警与名次区间提示，用于定位线上/线下差异来源。

---

## 5. 总结

AlphaGPT V0.1 不仅仅是一个公式生成器，更是一个**严谨的量化实验平台**。

*   通过 **截面数据**，我们锁定了 Alpha 的本质（选股）。
*   通过 **双引擎验证**，我们排除了计算逻辑的 Bug。
*   通过 **实盘仿真过滤**，我们拒绝了“纸面富贵”。

这一套标准化的流程，为后续 V0.2 引入更复杂的量价特征奠定了可信的基础。
